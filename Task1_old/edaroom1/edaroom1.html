<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ManeRoom1 EDA Dashboard (JSON Data)</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f8f8f8;
      margin: 0;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .chart-container {
      margin: 20px auto;
      background: #fff;
      padding: 10px 20px;
      border: 1px solid #ddd;
      max-width: 900px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .chart-title {
      font-size: 20px;
      text-align: center;
      margin-bottom: 10px;
    }
    .axis-label {
      font-size: 12px;
      fill: #333;
    }
    .tooltip {
      position: absolute;
      pointer-events: none;
      background: #fff;
      border: 1px solid #ccc;
      padding: 5px;
      font-size: 12px;
      opacity: 0;
    }
  </style>
</head>
<body>
  <h1>ManeRoom1 EDA Dashboard (JSON Data)</h1>

  <script>
    // 1) Define a time parser for timestamps like "2022-09-28 13:43:00"
    const parseTime = d3.timeParse("%Y-%m-%d %H:%M:%S");

    // Our variables: co2, temperature, humidity, pressure, voc
    const variables = ["co2", "temperature", "humidity", "pressure", "voc"];

    // 2) Load the JSON file (mane_room_1.json)
    d3.json("../json/mane_room_1.json").then(data => {
      // A) Parse each record
      data.forEach(d => {
        // Convert time_stamp string to a Date object
        d.time_stamp = parseTime(d.time_stamp);

        // Convert numeric fields
        d.co2         = +d.co2;
        d.humidity    = +d.humidity;
        d.temperature = +d.temperature;
        d.voc         = +d.voc;
        d.pressure    = +d.pressure;

        // Derive additional fields automatically
        d.hour    = d.time_stamp.getHours();
        d.weekday = (d.time_stamp.getDay() + 6) % 7; // Monday=0, Sunday=6
        d.month   = d.time_stamp.getMonth() + 1;       // 1..12
        d.day     = d.time_stamp.getDate();            // 1..31
        d.year    = d.time_stamp.getFullYear();

        // For bar charts
        d.date = d3.timeFormat("%Y-%m-%d")(d.time_stamp);
      });

      // B) Helper functions
      // Helper: median
      function median(values) {
        const sorted = values.slice().sort(d3.ascending);
        const mid = Math.floor(sorted.length / 2);
        return values.length % 2
          ? sorted[mid]
          : (sorted[mid - 1] + sorted[mid]) / 2;
      }

      // Helper: Pearson correlation
      function pearsonCorrelation(x, y) {
        const meanX = d3.mean(x), meanY = d3.mean(y);
        const numerator = d3.sum(x.map((val, i) => (val - meanX) * (y[i] - meanY)));
        const denominator = Math.sqrt(
          d3.sum(x.map(val => (val - meanX) ** 2)) *
          d3.sum(y.map(val => (val - meanY) ** 2))
        );
        return numerator / denominator;
      }

      // Single tooltip for all charts
      const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip");

      // (A) Hourly Line Chart (existing)
      function drawHourlyChart(yearData, variable, year) {
        // Group by hour
        const grouped = Array.from(
          d3.group(yearData, d => d.hour),
          ([hr, vals]) => ({
            hour: +hr,
            meanVal: d3.mean(vals, d => d[variable]),
            medianVal: median(vals.map(d => d[variable]))
          })
        ).sort((a, b) => d3.ascending(a.hour, b.hour));

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`Hourly Variation - ${variable.toUpperCase()} - Year ${year}`);

        const svgWidth = 800, svgHeight = 400;
        const margin = { top: 20, right: 30, bottom: 50, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;

        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);

        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // X scale: hour 0..23
        const x = d3.scaleLinear()
          .domain([0, 23])
          .range([0, width]);
        g.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(d3.axisBottom(x).ticks(24))
          .append("text")
          .attr("x", width / 2)
          .attr("y", 40)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text("Hour");

        // Y scale
        const minVal = d3.min(grouped, d => Math.min(d.meanVal, d.medianVal));
        const maxVal = d3.max(grouped, d => Math.max(d.meanVal, d.medianVal));
        const y = d3.scaleLinear()
          .domain([minVal, maxVal])
          .nice()
          .range([height, 0]);
        g.append("g")
          .call(d3.axisLeft(y))
          .append("text")
          .attr("transform", "rotate(-90)")
          .attr("x", -height / 2)
          .attr("y", -45)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text(variable.toUpperCase());

        const lineMean = d3.line()
          .x(d => x(d.hour))
          .y(d => y(d.meanVal));
        const lineMedian = d3.line()
          .x(d => x(d.hour))
          .y(d => y(d.medianVal));

        // Mean line
        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 2)
          .attr("d", lineMean);

        // Median line
        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "orange")
          .attr("stroke-width", 2)
          .attr("d", lineMedian);

        // Mean circles
        g.selectAll(".mean-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "mean-circle")
          .attr("cx", d => x(d.hour))
          .attr("cy", d => y(d.meanVal))
          .attr("r", 4)
          .attr("fill", "steelblue")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Hour: ${d.hour}<br>` +
              `Mean ${variable.toUpperCase()}: ${d.meanVal.toFixed(2)}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });

        // Median circles
        g.selectAll(".median-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "median-circle")
          .attr("cx", d => x(d.hour))
          .attr("cy", d => y(d.medianVal))
          .attr("r", 4)
          .attr("fill", "orange")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Hour: ${d.hour}<br>` +
              `Median ${variable.toUpperCase()}: ${d.medianVal.toFixed(2)}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });
      }

      // (B) Weekly Variation Line Chart
      function drawWeeklyChart(yearData, variable, year) {
        // Group by weekday (Monday=0 to Sunday=6)
        const grouped = Array.from(
          d3.group(yearData, d => d.weekday),
          ([wd, vals]) => ({
            weekday: +wd,
            meanVal: d3.mean(vals, d => d[variable]),
            medianVal: median(vals.map(d => d[variable]))
          })
        ).sort((a, b) => d3.ascending(a.weekday, b.weekday));

        // Define weekday names if desired
        const weekdayNames = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`Weekly Variation - ${variable.toUpperCase()} - Year ${year}`);

        const svgWidth = 800, svgHeight = 400;
        const margin = { top: 20, right: 30, bottom: 50, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;

        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);

        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // X scale: weekday 0..6
        const x = d3.scaleLinear()
          .domain([0, 6])
          .range([0, width]);
        g.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(d3.axisBottom(x).ticks(7).tickFormat(d => weekdayNames[d]))
          .append("text")
          .attr("x", width / 2)
          .attr("y", 40)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text("Weekday");

        // Y scale
        const minVal = d3.min(grouped, d => Math.min(d.meanVal, d.medianVal));
        const maxVal = d3.max(grouped, d => Math.max(d.meanVal, d.medianVal));
        const y = d3.scaleLinear()
          .domain([minVal, maxVal])
          .nice()
          .range([height, 0]);
        g.append("g")
          .call(d3.axisLeft(y))
          .append("text")
          .attr("transform", "rotate(-90)")
          .attr("x", -height / 2)
          .attr("y", -45)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text(variable.toUpperCase());

        const lineMean = d3.line()
          .x(d => x(d.weekday))
          .y(d => y(d.meanVal));
        const lineMedian = d3.line()
          .x(d => x(d.weekday))
          .y(d => y(d.medianVal));

        // Mean line
        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 2)
          .attr("d", lineMean);

        // Median line
        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "orange")
          .attr("stroke-width", 2)
          .attr("d", lineMedian);

        // Mean circles
        g.selectAll(".mean-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "mean-circle")
          .attr("cx", d => x(d.weekday))
          .attr("cy", d => y(d.meanVal))
          .attr("r", 4)
          .attr("fill", "steelblue")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Weekday: ${weekdayNames[d.weekday]}<br>` +
              `Mean ${variable.toUpperCase()}: ${d.meanVal.toFixed(2)}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });

        // Median circles
        g.selectAll(".median-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "median-circle")
          .attr("cx", d => x(d.weekday))
          .attr("cy", d => y(d.medianVal))
          .attr("r", 4)
          .attr("fill", "orange")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Weekday: ${weekdayNames[d.weekday]}<br>` +
              `Median ${variable.toUpperCase()}: ${d.medianVal.toFixed(2)}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });
      }

      // (C) Monthly Variation Line Chart
      function drawMonthlyChart(yearData, variable, year) {
        // Group by month (1..12)
        const grouped = Array.from(
          d3.group(yearData, d => d.month),
          ([m, vals]) => ({
            month: +m,
            meanVal: d3.mean(vals, d => d[variable]),
            medianVal: median(vals.map(d => d[variable]))
          })
        ).sort((a, b) => d3.ascending(a.month, b.month));

        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`Monthly Variation - ${variable.toUpperCase()} - Year ${year}`);

        const svgWidth = 800, svgHeight = 400;
        const margin = { top: 20, right: 30, bottom: 50, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;

        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);

        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // X scale: month 1..12 mapped to 0..11 for simplicity
        const x = d3.scaleLinear()
          .domain([1, 12])
          .range([0, width]);
        g.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(d3.axisBottom(x).ticks(12).tickFormat(d => monthNames[d - 1]))
          .append("text")
          .attr("x", width / 2)
          .attr("y", 40)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text("Month");

        // Y scale
        const minVal = d3.min(grouped, d => Math.min(d.meanVal, d.medianVal));
        const maxVal = d3.max(grouped, d => Math.max(d.meanVal, d.medianVal));
        const y = d3.scaleLinear()
          .domain([minVal, maxVal])
          .nice()
          .range([height, 0]);
        g.append("g")
          .call(d3.axisLeft(y))
          .append("text")
          .attr("transform", "rotate(-90)")
          .attr("x", -height / 2)
          .attr("y", -45)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text(variable.toUpperCase());

        const lineMean = d3.line()
          .x(d => x(d.month))
          .y(d => y(d.meanVal));
        const lineMedian = d3.line()
          .x(d => x(d.month))
          .y(d => y(d.medianVal));

        // Mean line
        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 2)
          .attr("d", lineMean);

        // Median line
        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "orange")
          .attr("stroke-width", 2)
          .attr("d", lineMedian);

        // Mean circles
        g.selectAll(".mean-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "mean-circle")
          .attr("cx", d => x(d.month))
          .attr("cy", d => y(d.meanVal))
          .attr("r", 4)
          .attr("fill", "steelblue")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Month: ${monthNames[d.month - 1]}<br>` +
              `Mean ${variable.toUpperCase()}: ${d.meanVal.toFixed(2)}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });

        // Median circles
        g.selectAll(".median-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "median-circle")
          .attr("cx", d => x(d.month))
          .attr("cy", d => y(d.medianVal))
          .attr("r", 4)
          .attr("fill", "orange")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Month: ${monthNames[d.month - 1]}<br>` +
              `Median ${variable.toUpperCase()}: ${d.medianVal.toFixed(2)}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });
      }

      // (D) Correlation Heatmap (All Years Combined) + Legend (existing)
      function drawCorrelationHeatmap(allData) {
        const vars = ["co2", "humidity", "temperature", "voc", "pressure"];
        const corrData = [];
        vars.forEach(v1 => {
          vars.forEach(v2 => {
            const arr1 = allData.map(d => d[v1]);
            const arr2 = allData.map(d => d[v2]);
            const corr = pearsonCorrelation(arr1, arr2);
            corrData.push({ var1: v1, var2: v2, correlation: corr });
          });
        });

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text("Correlation Heatmap - All Years Combined");

        const svgWidth = 600, svgHeight = 600;
        const margin = { top: 50, right: 60, bottom: 50, left: 50 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;

        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);

        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const colorScale = d3.scaleSequential(d3.interpolateRdBu)
          .domain([-1, 1]);

        const gridSize = Math.floor(width / vars.length);

        g.selectAll(".corr-rect")
          .data(corrData)
          .enter().append("rect")
          .attr("class", "corr-rect")
          .attr("x", d => vars.indexOf(d.var1) * gridSize)
          .attr("y", d => vars.indexOf(d.var2) * gridSize)
          .attr("width", gridSize)
          .attr("height", gridSize)
          .attr("fill", d => colorScale(d.correlation))
          .attr("stroke", "#fff")
          .attr("stroke-width", 1)
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Vars: ${d.var1} &amp; ${d.var2}<br>` +
              `Corr: ${d.correlation.toFixed(2)}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });

        g.selectAll(".corr-text")
          .data(corrData)
          .enter().append("text")
          .attr("x", d => vars.indexOf(d.var1) * gridSize + gridSize / 2)
          .attr("y", d => vars.indexOf(d.var2) * gridSize + gridSize / 2)
          .attr("dy", ".35em")
          .attr("text-anchor", "middle")
          .style("font-size", "10px")
          .text(d => d.correlation.toFixed(2));

        vars.forEach((v, i) => {
          g.append("text")
            .attr("x", i * gridSize + gridSize / 2)
            .attr("y", -5)
            .attr("text-anchor", "middle")
            .attr("class", "axis-label")
            .text(v);
          g.append("text")
            .attr("x", -5)
            .attr("y", i * gridSize + gridSize / 2)
            .attr("dy", ".35em")
            .attr("text-anchor", "end")
            .attr("class", "axis-label")
            .text(v);
        });

        const legendHeight = 200;
        const legendWidth = 10;
        const legendX = width + 10;
        const legendY = (height - legendHeight) / 2;

        const legendScale = d3.scaleLinear()
          .domain(colorScale.domain())
          .range([legendHeight, 0]);

        const legendAxis = d3.axisRight(legendScale).ticks(5);

        const legendG = g.append("g")
          .attr("transform", `translate(${legendX},${legendY})`);

        const legendData = d3.range(legendHeight);
        legendG.selectAll(".legend-rect")
          .data(legendData)
          .enter().append("rect")
          .attr("class", "legend-rect")
          .attr("x", 0)
          .attr("y", d => d)
          .attr("width", legendWidth)
          .attr("height", 1)
          .attr("fill", d => {
            const t = 1 - d / legendHeight;
            const corrVal = legendScale.invert(t * legendHeight);
            return colorScale(corrVal);
          });

        legendG.append("g")
          .attr("transform", `translate(${legendWidth},0)`)
          .call(legendAxis);

        legendG.append("text")
          .attr("x", legendWidth / 2)
          .attr("y", -10)
          .attr("text-anchor", "middle")
          .text("Correlation");
      }

      // (E) Daily Bar Chart (existing)
      function drawDailyBarChart(yearData, year) {
        const entryCounts = Array.from(
          d3.rollup(yearData, v => v.length, d => d.date),
          ([date, count]) => ({ date: new Date(date), count })
        ).sort((a, b) => d3.ascending(a.date, b.date));

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`Daily Entry Counts - Year ${year}`);

        const svgWidth = 900, svgHeight = 500;
        const margin = { top: 20, right: 30, bottom: 50, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;

        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);

        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const x = d3.scaleBand()
          .domain(entryCounts.map(d => d3.timeFormat("%Y-%m-%d")(d.date)))
          .range([0, width])
          .padding(0.1);

        g.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(d3.axisBottom(x))
          .selectAll("text")
          .attr("transform", "rotate(-45)")
          .style("text-anchor", "end");

        const y = d3.scaleLinear()
          .domain([0, d3.max(entryCounts, d => d.count)])
          .nice()
          .range([height, 0]);
        g.append("g").call(d3.axisLeft(y));

        g.selectAll(".bar")
          .data(entryCounts)
          .enter().append("rect")
          .attr("class", "bar")
          .attr("x", d => x(d3.timeFormat("%Y-%m-%d")(d.date)))
          .attr("y", d => y(d.count))
          .attr("width", x.bandwidth())
          .attr("height", d => height - y(d.count))
          .attr("fill", "teal")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Date: ${d3.timeFormat("%Y-%m-%d")(d.date)}<br>` +
              `Count: ${d.count}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });
      }

      // (F) Calendar Heatmap (existing)
      function drawCalendarHeatmap(yearData, variable, year) {
        const grouped = d3.rollups(
          yearData,
          v => d3.mean(v, d => d[variable]),
          d => d.month,
          d => d.day
        );

        let calData = [];
        grouped.forEach(([m, dayArray]) => {
          dayArray.forEach(([day, val]) => {
            calData.push({ month: m, day: day, value: val });
          });
        });

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`${variable.toUpperCase()} Calendar Heatmap - Year ${year}`);

        const svgWidth = 800, svgHeight = 400;
        const margin = { top: 50, right: 70, bottom: 20, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;

        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);

        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const months = d3.range(1, 13);
        const days = d3.range(1, 32);
        const cellWidth = width / 31;
        const cellHeight = height / 12;

        const calValues = calData.map(d => d.value).filter(v => !isNaN(v));
        const [minVal, maxVal] = d3.extent(calValues);
        const colorScale = d3.scaleSequential(d3.interpolateViridis)
          .domain([minVal, maxVal]);

        const lookup = {};
        calData.forEach(d => {
          lookup[`${d.month}-${d.day}`] = d.value;
        });

        months.forEach((m, rowIndex) => {
          days.forEach(day => {
            const key = `${m}-${day}`;
            const val = lookup[key];
            g.append("rect")
              .attr("x", (day - 1) * cellWidth)
              .attr("y", rowIndex * cellHeight)
              .attr("width", cellWidth)
              .attr("height", cellHeight)
              .attr("fill", val !== undefined ? colorScale(val) : "#eee")
              .attr("stroke", "#fff")
              .attr("stroke-width", 1)
              .on("mouseover", (event) => {
                if (val !== undefined) {
                  tooltip.transition().duration(200).style("opacity", 0.9);
                  tooltip.html(`
                    <strong>${variable.toUpperCase()}</strong><br>
                    Year: ${year}<br>
                    Month-Day: ${m}-${day}<br>
                    Value: ${val.toFixed(2)}
                  `)
                  .style("left", (event.pageX + 10) + "px")
                  .style("top", (event.pageY - 28) + "px");
                }
              })
              .on("mouseout", () => {
                tooltip.transition().duration(500).style("opacity", 0);
              });
          });
        });

        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        months.forEach((m, i) => {
          g.append("text")
            .attr("x", -10)
            .attr("y", i * cellHeight + cellHeight / 2)
            .attr("dy", ".35em")
            .attr("text-anchor", "end")
            .style("font-size", "10px")
            .text(monthNames[m - 1]);
        });

        const legendHeight = 150;
        const legendWidth = 10;
        const legendX = width + 10;
        const legendY = (height - legendHeight) / 2;

        const legendScale = d3.scaleLinear()
          .domain(colorScale.domain())
          .range([legendHeight, 0]);

        const legendAxis = d3.axisRight(legendScale).ticks(5);

        const legendG = g.append("g")
          .attr("transform", `translate(${legendX},${legendY})`);

        const legendData = d3.range(legendHeight);
        legendG.selectAll(".legend-rect")
          .data(legendData)
          .enter().append("rect")
          .attr("class", "legend-rect")
          .attr("x", 0)
          .attr("y", d => d)
          .attr("width", legendWidth)
          .attr("height", 1)
          .attr("fill", d => {
            const t = 1 - d / legendHeight;
            const val = legendScale.invert(t * legendHeight);
            return colorScale(val);
          });

        legendG.append("g")
          .attr("transform", `translate(${legendWidth},0)`)
          .call(legendAxis);

        legendG.append("text")
          .attr("x", legendWidth / 2)
          .attr("y", -10)
          .attr("text-anchor", "middle")
          .text(variable.toUpperCase());
      }

      // Execution Order

      // 1) Get all unique years from the data (once only!)
      const allYears = [...new Set(data.map(d => d.year))].sort(d3.ascending);

      // 2) For each year, for each variable: Draw Hourly, Weekly, and Monthly charts
      allYears.forEach(year => {
        const yearData = data.filter(d => d.year === year);
        if (yearData.length) {
          variables.forEach(variable => {
            drawHourlyChart(yearData, variable, year);
            drawWeeklyChart(yearData, variable, year);
            drawMonthlyChart(yearData, variable, year);
          });
        }
      });

      // 3) Correlation Heatmap (All Years Combined)
      drawCorrelationHeatmap(data);

      // 4) Daily Entry Counts (Bar Chart) for each year
      allYears.forEach(year => {
        const yearData = data.filter(d => d.year === year);
        if (yearData.length) {
          drawDailyBarChart(yearData, year);
        }
      });

      // 5) Calendar Heatmaps: For each year, for each variable
      allYears.forEach(year => {
        const yearData = data.filter(d => d.year === year);
        if (yearData.length) {
          variables.forEach(variable => {
            drawCalendarHeatmap(yearData, variable, year);
          });
        }
      });
    });
  </script>
</body>
</html>
