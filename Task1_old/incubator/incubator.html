<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>EDA Dashboard (inc_co2, inc_temp) JSON with Multiple Years</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f8f8f8;
      margin: 0;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .chart-container {
      margin: 20px auto;
      background: #fff;
      padding: 10px 20px;
      border: 1px solid #ddd;
      max-width: 900px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .chart-title {
      font-size: 20px;
      text-align: center;
      margin-bottom: 10px;
    }
    .axis-label {
      font-size: 12px;
      fill: #333;
    }
    .tooltip {
      position: absolute;
      pointer-events: none;
      background: #fff;
      border: 1px solid #ccc;
      padding: 5px;
      font-size: 12px;
      opacity: 0;
    }
  </style>
</head>
<body>
  <h1>EDA Dashboard (inc_co2, inc_temp)</h1>

  <script>
    // 1) Define a time parser for "DD/MM/YY HH:MM"
    //    Example: "28/09/22 13:26"
    const parseTime = d3.timeParse("%d/%m/%y %H:%M");

    // We have two variables in the dataset: inc_co2 and inc_temp
    const variables = ["inc_co2", "inc_temp"];

    // 2) Load the JSON file (adjust path if needed)
    d3.json("../json/incubator.json").then(data => {
      // A) Parse each record
      data.forEach(d => {
        // Convert time_stamp string to a Date object
        let parsedDate = parseTime(d.time_stamp);
        // If parsedDate is before year 2000, add 100 years (e.g. "22" => 2022)
        if (parsedDate && parsedDate.getFullYear() < 2000) {
          parsedDate.setFullYear(parsedDate.getFullYear() + 100);
        }
        d.time_stamp = parsedDate;

        // Convert numeric fields
        d.inc_co2 = +d.inc_co2;
        d.inc_temp = +d.inc_temp;

        // Derive additional fields automatically
        d.hour = d.time_stamp.getHours();
        d.weekday = (d.time_stamp.getDay() + 6) % 7; // Monday=0
        d.month = d.time_stamp.getMonth() + 1;       // 1..12
        d.day = d.time_stamp.getDate();              // 1..31
        d.year = d.time_stamp.getFullYear();

        // For bar charts
        d.date = d3.timeFormat("%Y-%m-%d")(d.time_stamp);
      });

      // 2B) Collect all unique years from the data
      const allYears = [...new Set(data.map(d => d.year))].sort(d3.ascending);

      // Helper: median
      function median(values) {
        const sorted = values.slice().sort(d3.ascending);
        const mid = Math.floor(sorted.length / 2);
        return values.length % 2
          ? sorted[mid]
          : (sorted[mid - 1] + sorted[mid]) / 2;
      }

      // Helper: Pearson correlation
      function pearsonCorrelation(x, y) {
        const meanX = d3.mean(x), meanY = d3.mean(y);
        const numerator = d3.sum(x.map((val, i) => (val - meanX) * (y[i] - meanY)));
        const denominator = Math.sqrt(
          d3.sum(x.map(val => (val - meanX) ** 2)) *
          d3.sum(y.map(val => (val - meanY) ** 2))
        );
        return numerator / denominator;
      }

      // A single tooltip for all charts
      const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip");

      // =================================================
      // Chart Functions
      // =================================================

      // (A) Hourly Line Chart (mean & median)
      function drawHourlyChart(yearData, variable, year) {
        const grouped = Array.from(
          d3.group(yearData, d => d.hour),
          ([hr, vals]) => ({
            hour: +hr,
            meanVal: d3.mean(vals, d => d[variable]),
            medianVal: median(vals.map(d => d[variable]))
          })
        ).sort((a, b) => d3.ascending(a.hour, b.hour));

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`Hourly Variation - ${variable.toUpperCase()} - Year ${year}`);

        const svgWidth = 800, svgHeight = 400;
        const margin = { top: 20, right: 30, bottom: 50, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;

        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);
        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const x = d3.scaleLinear().domain([0, 23]).range([0, width]);
        g.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(d3.axisBottom(x).ticks(24))
          .append("text")
          .attr("x", width / 2)
          .attr("y", 40)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text("Hour");

        const minVal = d3.min(grouped, d => Math.min(d.meanVal, d.medianVal));
        const maxVal = d3.max(grouped, d => Math.max(d.meanVal, d.medianVal));
        const y = d3.scaleLinear().domain([minVal, maxVal]).nice().range([height, 0]);
        g.append("g")
          .call(d3.axisLeft(y))
          .append("text")
          .attr("transform", "rotate(-90)")
          .attr("x", -height / 2)
          .attr("y", -45)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text(variable.toUpperCase());

        const lineMean = d3.line().x(d => x(d.hour)).y(d => y(d.meanVal));
        const lineMedian = d3.line().x(d => x(d.hour)).y(d => y(d.medianVal));

        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 2)
          .attr("d", lineMean);

        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "orange")
          .attr("stroke-width", 2)
          .attr("d", lineMedian);

        g.selectAll(".mean-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "mean-circle")
          .attr("cx", d => x(d.hour))
          .attr("cy", d => y(d.meanVal))
          .attr("r", 4)
          .attr("fill", "steelblue")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`Hour: ${d.hour}<br>Mean ${variable.toUpperCase()}: ${d.meanVal.toFixed(2)}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));

        g.selectAll(".median-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "median-circle")
          .attr("cx", d => x(d.hour))
          .attr("cy", d => y(d.medianVal))
          .attr("r", 4)
          .attr("fill", "orange")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`Hour: ${d.hour}<br>Median ${variable.toUpperCase()}: ${d.medianVal.toFixed(2)}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));
      }

      // (B) Weekly Variation Line Chart (mean & median)
      function drawWeeklyChart(yearData, variable, year) {
        const grouped = Array.from(
          d3.group(yearData, d => d.weekday),
          ([wd, vals]) => ({
            weekday: +wd,
            meanVal: d3.mean(vals, d => d[variable]),
            medianVal: median(vals.map(d => d[variable]))
          })
        ).sort((a, b) => d3.ascending(a.weekday, b.weekday));

        // Map weekday numbers to names (Monday=0)
        const weekdayNames = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`Weekly Variation - ${variable.toUpperCase()} - Year ${year}`);

        const svgWidth = 800, svgHeight = 400;
        const margin = { top: 20, right: 30, bottom: 50, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);
        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const x = d3.scaleLinear().domain([0, 6]).range([0, width]);
        g.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(d3.axisBottom(x).ticks(7).tickFormat(d => weekdayNames[d]))
          .append("text")
          .attr("x", width / 2)
          .attr("y", 40)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text("Weekday");

        const minVal = d3.min(grouped, d => Math.min(d.meanVal, d.medianVal));
        const maxVal = d3.max(grouped, d => Math.max(d.meanVal, d.medianVal));
        const y = d3.scaleLinear().domain([minVal, maxVal]).nice().range([height, 0]);
        g.append("g")
          .call(d3.axisLeft(y))
          .append("text")
          .attr("transform", "rotate(-90)")
          .attr("x", -height / 2)
          .attr("y", -45)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text(variable.toUpperCase());

        const lineMean = d3.line().x(d => x(d.weekday)).y(d => y(d.meanVal));
        const lineMedian = d3.line().x(d => x(d.weekday)).y(d => y(d.medianVal));

        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 2)
          .attr("d", lineMean);

        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "orange")
          .attr("stroke-width", 2)
          .attr("d", lineMedian);

        g.selectAll(".mean-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "mean-circle")
          .attr("cx", d => x(d.weekday))
          .attr("cy", d => y(d.meanVal))
          .attr("r", 4)
          .attr("fill", "steelblue")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`Weekday: ${weekdayNames[d.weekday]}<br>Mean ${variable.toUpperCase()}: ${d.meanVal.toFixed(2)}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));

        g.selectAll(".median-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "median-circle")
          .attr("cx", d => x(d.weekday))
          .attr("cy", d => y(d.medianVal))
          .attr("r", 4)
          .attr("fill", "orange")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`Weekday: ${weekdayNames[d.weekday]}<br>Median ${variable.toUpperCase()}: ${d.medianVal.toFixed(2)}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));
      }

      // (C) Monthly Variation Line Chart (mean & median)
      function drawMonthlyChart(yearData, variable, year) {
        const grouped = Array.from(
          d3.group(yearData, d => d.month),
          ([m, vals]) => ({
            month: +m,
            meanVal: d3.mean(vals, d => d[variable]),
            medianVal: median(vals.map(d => d[variable]))
          })
        ).sort((a, b) => d3.ascending(a.month, b.month));

        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`Monthly Variation - ${variable.toUpperCase()} - Year ${year}`);

        const svgWidth = 800, svgHeight = 400;
        const margin = { top: 20, right: 30, bottom: 50, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);
        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const x = d3.scaleLinear().domain([1, 12]).range([0, width]);
        g.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(d3.axisBottom(x).ticks(12).tickFormat(d => monthNames[d - 1]))
          .append("text")
          .attr("x", width / 2)
          .attr("y", 40)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text("Month");

        const minVal = d3.min(grouped, d => Math.min(d.meanVal, d.medianVal));
        const maxVal = d3.max(grouped, d => Math.max(d.meanVal, d.medianVal));
        const y = d3.scaleLinear().domain([minVal, maxVal]).nice().range([height, 0]);
        g.append("g")
          .call(d3.axisLeft(y))
          .append("text")
          .attr("transform", "rotate(-90)")
          .attr("x", -height / 2)
          .attr("y", -45)
          .attr("fill", "#000")
          .attr("text-anchor", "middle")
          .attr("class", "axis-label")
          .text(variable.toUpperCase());

        const lineMean = d3.line().x(d => x(d.month)).y(d => y(d.meanVal));
        const lineMedian = d3.line().x(d => x(d.month)).y(d => y(d.medianVal));

        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 2)
          .attr("d", lineMean);

        g.append("path")
          .datum(grouped)
          .attr("fill", "none")
          .attr("stroke", "orange")
          .attr("stroke-width", 2)
          .attr("d", lineMedian);

        g.selectAll(".mean-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "mean-circle")
          .attr("cx", d => x(d.month))
          .attr("cy", d => y(d.meanVal))
          .attr("r", 4)
          .attr("fill", "steelblue")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`Month: ${monthNames[d.month - 1]}<br>Mean ${variable.toUpperCase()}: ${d.meanVal.toFixed(2)}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));

        g.selectAll(".median-circle")
          .data(grouped)
          .enter().append("circle")
          .attr("class", "median-circle")
          .attr("cx", d => x(d.month))
          .attr("cy", d => y(d.medianVal))
          .attr("r", 4)
          .attr("fill", "orange")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`Month: ${monthNames[d.month - 1]}<br>Median ${variable.toUpperCase()}: ${d.medianVal.toFixed(2)}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));
      }

      // (D) Correlation Heatmap (All Data Combined)
      function drawCorrelationHeatmap(allData) {
        const vars = ["inc_co2", "inc_temp"];
        const corrData = [];
        vars.forEach(v1 => {
          vars.forEach(v2 => {
            const arr1 = allData.map(d => d[v1]);
            const arr2 = allData.map(d => d[v2]);
            const corr = pearsonCorrelation(arr1, arr2);
            corrData.push({ var1: v1, var2: v2, correlation: corr });
          });
        });

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text("Correlation Heatmap - All Data");

        const svgWidth = 400, svgHeight = 400;
        const margin = { top: 50, right: 60, bottom: 50, left: 50 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);
        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const colorScale = d3.scaleSequential(d3.interpolateRdBu)
          .domain([-1, 1]);
        const gridSize = Math.floor(width / vars.length);

        g.selectAll(".corr-rect")
          .data(corrData)
          .enter().append("rect")
          .attr("class", "corr-rect")
          .attr("x", d => vars.indexOf(d.var1) * gridSize)
          .attr("y", d => vars.indexOf(d.var2) * gridSize)
          .attr("width", gridSize)
          .attr("height", gridSize)
          .attr("fill", d => colorScale(d.correlation))
          .attr("stroke", "#fff")
          .attr("stroke-width", 1)
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Vars: ${d.var1} &amp; ${d.var2}<br>` +
              `Corr: ${d.correlation.toFixed(2)}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });

        g.selectAll(".corr-text")
          .data(corrData)
          .enter().append("text")
          .attr("x", d => vars.indexOf(d.var1) * gridSize + gridSize / 2)
          .attr("y", d => vars.indexOf(d.var2) * gridSize + gridSize / 2)
          .attr("dy", ".35em")
          .attr("text-anchor", "middle")
          .style("font-size", "10px")
          .text(d => d.correlation.toFixed(2));

        vars.forEach((v, i) => {
          g.append("text")
            .attr("x", i * gridSize + gridSize / 2)
            .attr("y", -5)
            .attr("text-anchor", "middle")
            .attr("class", "axis-label")
            .text(v);
          g.append("text")
            .attr("x", -5)
            .attr("y", i * gridSize + gridSize / 2)
            .attr("dy", ".35em")
            .attr("text-anchor", "end")
            .attr("class", "axis-label")
            .text(v);
        });

        const legendHeight = 120;
        const legendWidth = 10;
        const legendX = width + 10;
        const legendY = (height - legendHeight) / 2;
        const legendScale = d3.scaleLinear()
          .domain(colorScale.domain())
          .range([legendHeight, 0]);
        const legendAxis = d3.axisRight(legendScale).ticks(5);
        const legendG = g.append("g")
          .attr("transform", `translate(${legendX},${legendY})`);
        const legendData = d3.range(legendHeight);
        legendG.selectAll(".legend-rect")
          .data(legendData)
          .enter().append("rect")
          .attr("class", "legend-rect")
          .attr("x", 0)
          .attr("y", d => d)
          .attr("width", legendWidth)
          .attr("height", 1)
          .attr("fill", d => {
            const t = 1 - d / legendHeight;
            const corrVal = legendScale.invert(t * legendHeight);
            return colorScale(corrVal);
          });
        legendG.append("g")
          .attr("transform", `translate(${legendWidth},0)`)
          .call(legendAxis);
        legendG.append("text")
          .attr("x", legendWidth / 2)
          .attr("y", -10)
          .attr("text-anchor", "middle")
          .text("Correlation");
      }

      // (E) Daily Entry Counts (Bar Chart) for each year
      function drawDailyBarChart(yearData, year) {
        const entryCounts = Array.from(
          d3.rollup(yearData, v => v.length, d => d.date),
          ([date, count]) => ({ date: new Date(date), count })
        ).sort((a, b) => d3.ascending(a.date, b.date));

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`Daily Entry Counts - Year ${year}`);

        const svgWidth = 900, svgHeight = 500;
        const margin = { top: 20, right: 30, bottom: 50, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);
        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const x = d3.scaleBand()
          .domain(entryCounts.map(d => d3.timeFormat("%Y-%m-%d")(d.date)))
          .range([0, width])
          .padding(0.1);
        g.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(d3.axisBottom(x))
          .selectAll("text")
          .attr("transform", "rotate(-45)")
          .style("text-anchor", "end");

        const y = d3.scaleLinear()
          .domain([0, d3.max(entryCounts, d => d.count)])
          .nice()
          .range([height, 0]);
        g.append("g").call(d3.axisLeft(y));

        g.selectAll(".bar")
          .data(entryCounts)
          .enter().append("rect")
          .attr("class", "bar")
          .attr("x", d => x(d3.timeFormat("%Y-%m-%d")(d.date)))
          .attr("y", d => y(d.count))
          .attr("width", x.bandwidth())
          .attr("height", d => height - y(d.count))
          .attr("fill", "teal")
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(
              `Date: ${d3.timeFormat("%Y-%m-%d")(d.date)}<br>` +
              `Count: ${d.count}`
            )
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
          });
      }

      // (F) Calendar Heatmaps: For each unique year, for each variable
      function drawCalendarHeatmap(yearData, variable, year) {
        const grouped = d3.rollups(
          yearData,
          v => d3.mean(v, d => d[variable]),
          d => d.month,
          d => d.day
        );
        let calData = [];
        grouped.forEach(([m, dayArray]) => {
          dayArray.forEach(([day, val]) => {
            calData.push({ month: m, day: day, value: val });
          });
        });

        const container = d3.select("body")
          .append("div")
          .attr("class", "chart-container");
        container.append("div")
          .attr("class", "chart-title")
          .text(`${variable.toUpperCase()} Calendar Heatmap - Year ${year}`);

        const svgWidth = 800, svgHeight = 400;
        const margin = { top: 50, right: 70, bottom: 20, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        const svg = container.append("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);
        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const months = d3.range(1, 13);
        const days = d3.range(1, 32);
        const cellWidth = width / 31;
        const cellHeight = height / 12;
        const calValues = calData.map(d => d.value).filter(v => !isNaN(v));
        const [minVal, maxVal] = d3.extent(calValues);
        const colorScale = d3.scaleSequential(d3.interpolateViridis)
          .domain([minVal, maxVal]);
        const lookup = {};
        calData.forEach(d => { lookup[`${d.month}-${d.day}`] = d.value; });

        months.forEach((m, rowIndex) => {
          days.forEach(day => {
            const key = `${m}-${day}`;
            const val = lookup[key];
            g.append("rect")
              .attr("x", (day - 1) * cellWidth)
              .attr("y", rowIndex * cellHeight)
              .attr("width", cellWidth)
              .attr("height", cellHeight)
              .attr("fill", val !== undefined ? colorScale(val) : "#eee")
              .attr("stroke", "#fff")
              .attr("stroke-width", 1)
              .on("mouseover", (event) => {
                if (val !== undefined) {
                  tooltip.transition().duration(200).style("opacity", 0.9);
                  tooltip.html(`
                    <strong>${variable.toUpperCase()}</strong><br>
                    Year: ${year}<br>
                    Month-Day: ${m}-${day}<br>
                    Value: ${val.toFixed(2)}
                  `)
                  .style("left", (event.pageX + 10) + "px")
                  .style("top", (event.pageY - 28) + "px");
                }
              })
              .on("mouseout", () => {
                tooltip.transition().duration(500).style("opacity", 0);
              });
          });
        });

        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        months.forEach((m, i) => {
          g.append("text")
            .attr("x", -10)
            .attr("y", i * cellHeight + cellHeight / 2)
            .attr("dy", ".35em")
            .attr("text-anchor", "end")
            .style("font-size", "10px")
            .text(monthNames[m - 1]);
        });

        const legendHeight = 150;
        const legendWidth = 10;
        const legendX = width + 10;
        const legendY = (height - legendHeight) / 2;
        const legendScale = d3.scaleLinear()
          .domain(colorScale.domain())
          .range([legendHeight, 0]);
        const legendAxis = d3.axisRight(legendScale).ticks(5);
        const legendG = g.append("g")
          .attr("transform", `translate(${legendX},${legendY})`);
        const legendData = d3.range(legendHeight);
        legendG.selectAll(".legend-rect")
          .data(legendData)
          .enter().append("rect")
          .attr("class", "legend-rect")
          .attr("x", 0)
          .attr("y", d => d)
          .attr("width", legendWidth)
          .attr("height", 1)
          .attr("fill", d => {
            const t = 1 - d / legendHeight;
            const val = legendScale.invert(t * legendHeight);
            return colorScale(val);
          });
        legendG.append("g")
          .attr("transform", `translate(${legendWidth},0)`)
          .call(legendAxis);
        legendG.append("text")
          .attr("x", legendWidth / 2)
          .attr("y", -10)
          .attr("text-anchor", "middle")
          .text(variable.toUpperCase());
      }

      // =================================================
      // Final Execution Order
      // =================================================

      // 1) Hourly Line Charts: For each unique year, for each variable
      allYears.forEach(year => {
        const yearData = data.filter(d => d.year === year);
        if (yearData.length) {
          variables.forEach(variable => {
            drawHourlyChart(yearData, variable, year);
          });
        }
      });

      // 2) Weekly Variation Charts: For each unique year, for each variable
      allYears.forEach(year => {
        const yearData = data.filter(d => d.year === year);
        if (yearData.length) {
          variables.forEach(variable => {
            drawWeeklyChart(yearData, variable, year);
          });
        }
      });

      // 3) Monthly Variation Charts: For each unique year, for each variable
      allYears.forEach(year => {
        const yearData = data.filter(d => d.year === year);
        if (yearData.length) {
          variables.forEach(variable => {
            drawMonthlyChart(yearData, variable, year);
          });
        }
      });

      // 4) Correlation Heatmap (All Data Combined)
      drawCorrelationHeatmap(data);

      // 5) Daily Entry Counts (Bar Chart) for each year
      allYears.forEach(year => {
        const yearData = data.filter(d => d.year === year);
        if (yearData.length) {
          drawDailyBarChart(yearData, year);
        }
      });

      // 6) Calendar Heatmaps: For each unique year, for each variable
      allYears.forEach(year => {
        const yearData = data.filter(d => d.year === year);
        if (yearData.length) {
          variables.forEach(variable => {
            drawCalendarHeatmap(yearData, variable, year);
          });
        }
      });
    });
  </script>
</body>
</html>
